//..............................................................................
//
//  This file is part of the LuaDoxyXML toolkit.
//
//  LuaDoxyXML is distributed under the MIT license.
//  For details see accompanying license.txt file,
//  the public copy of which is also available at:
//  http://tibbo.com/downloads/archive/luadoxyxml/license.txt
//
//..............................................................................

lookahead = 2;
ParserClassName = LuaParser;
TokenClassName = LuaToken;

Includes
{
	#include "LuaLexer.h"
	#include "Module.h"
}

CppIncludes
{
	#include "LuaParser.llk.h"
}

Members
{
	Module* m_module;
	ModuleItem* m_lastDeclaredItem;
	int m_scopeLevel;

	LuaParser(Module* module);

	bool
	variableDeclaration(
		const Token::Pos& pos,
		const sl::StringRef& name
		);

	bool
	functionDeclaration(
		const Token::Pos& pos,
		FunctionName* name,
		FunctionArgList* argList
		);
}

start
nullable
block
	:	statement*
	;

statement
	:	expression_stmt
	|	label
	|	LuaTokenKind_Goto LuaTokenKind_Identifier
	|	LuaTokenKind_Break
	|	LuaTokenKind_Return expression_list?
	|	LuaTokenKind_Do block LuaTokenKind_End
	|	LuaTokenKind_While
			{
				m_scopeLevel++;
			}
		expression LuaTokenKind_Do block LuaTokenKind_End
			{
				m_scopeLevel--;
			}
	|	LuaTokenKind_Repeat
			{
				m_scopeLevel++;
			}
		block
			{
				m_scopeLevel--;
			}
		LuaTokenKind_Until expression
	|	LuaTokenKind_If
			{
				m_scopeLevel++;
			}
		expression LuaTokenKind_Then block
		(LuaTokenKind_ElseIf expression LuaTokenKind_Then block)*
		(LuaTokenKind_Else block)?
			{
				m_scopeLevel--;
			}
		LuaTokenKind_End
	|	LuaTokenKind_For
			{
				m_scopeLevel++;
			}
		for_iterator LuaTokenKind_Do block LuaTokenKind_End
			{
				m_scopeLevel--;
			}
	|	LuaTokenKind_Function
			{
				m_scopeLevel++;
			}
		function_name function_body
			{
				if (!--m_scopeLevel)
					return functionDeclaration($1.m_pos, &$2.m_name, &$3.m_argList);
			}
	|	LuaTokenKind_Local
			{
				m_scopeLevel++;
			}
		LuaTokenKind_Function LuaTokenKind_Identifier function_body
			{
				m_scopeLevel--;
			}
	|	LuaTokenKind_Local name_list ('=' expression_list)?
	|	';'
	;

label
	:	LuaTokenKind_Context LuaTokenKind_Identifier LuaTokenKind_Context
	;

class
{
	FunctionName m_name;
}
function_name
	:	LuaTokenKind_Identifier
			{
				$.m_name.m_first = $1.m_data.m_string;
			}
		('.' LuaTokenKind_Identifier
			{
				$.m_name.m_list.insertTail($1.m_data.m_string);
			}
		)*
		(':' LuaTokenKind_Identifier
			{
				$.m_name.m_list.insertTail($1.m_data.m_string);
				$.m_name.m_isMethod = true;
			}
		)?
	;

for_iterator
	: 	LuaTokenKind_Identifier '=' expression ',' expression (',' expression)?
	| 	name_list LuaTokenKind_In expression_list
	;

class
{
	sl::BoxList<sl::StringRef> m_nameList;
}
name_list
	:	LuaTokenKind_Identifier
			{
				$.m_nameList.insertTail($1.m_data.m_string);
			}
		(',' LuaTokenKind_Identifier
			{
				$.m_nameList.insertTail($3.m_data.m_string);
			}
		)*
	;

expression_stmt
	:	postfix_expr (',' postfix_expr)*
		('=' expression_list
			{
				if (!m_scopeLevel && !$1.m_name.isEmpty())
					return variableDeclaration($1.m_pos, $1.m_name);
			}
		)?
	;

expression_list
	:	expression (',' expression)*
	;

expression
	:	unary_expr (bin_op expression)*
	;

unary_expr
	:	postfix_expr
	|	un_op unary_expr
	;

class
{
	Token::Pos m_pos;
	sl::StringRef m_name;
}
postfix_expr
	: 	primary_expr
			{
				$.m_pos = $1.m_pos;
				$.m_name = $1.m_name;
			}
		(postfix_op
			{
				$.m_name.clear();
			}
		)*
	;

postfix_op
	:	'[' expression ']'
	|	'.' LuaTokenKind_Identifier
	|	(':' LuaTokenKind_Identifier)? arguments
	;

class
{
	Token::Pos m_pos;
	sl::StringRef m_name;
}
primary_expr
	:	LuaTokenKind_Nil
	|	LuaTokenKind_False
	|	LuaTokenKind_True
	|	LuaTokenKind_Number
	|	LuaTokenKind_String
	|	LuaTokenKind_Identifier
			{
				$.m_pos = $1.m_pos;
				$.m_name = $1.m_data.m_string;
			}
	|	LuaTokenKind_Ellipsis
	|	LuaTokenKind_Function function_body
	|	table_constructor
	|	'(' expression ')'
	;

arguments
	: 	'(' expression_list? ')'
	|	table_constructor
	|	LuaTokenKind_String
	;

class
{
	FunctionArgList m_argList;
}
function_body
	:	'('
		(parameter_list
			{
				sl::takeOver(&$.m_argList, &$2.m_argList);
			}
		)?
		')' block LuaTokenKind_End
	;

class
{
	FunctionArgList m_argList;
}
parameter_list
	:	name_list
			{
				sl::takeOver(&$.m_argList.m_list, &$1.m_nameList);
			}
		(',' LuaTokenKind_Ellipsis
			{
				$.m_argList.m_isVarArg = true;
			}
		)?
	|	LuaTokenKind_Ellipsis
			{
				$.m_argList.m_isVarArg = true;
			}
	;

table_constructor
	:	'{' field_list? '}'
	;

field_list
	:	field (field_sep field?)*
	;

field
	:	'[' expression ']' '=' expression
	|	LuaTokenKind_Identifier '=' expression
	|	expression
	;

field_sep
	:	','
	|	';'
	;

bin_op
	:	LuaTokenKind_Or
	|	LuaTokenKind_And
	|	'<'
	|	'>'
	|	LuaTokenKind_Le
	|	LuaTokenKind_Ge
	|	LuaTokenKind_Ne
	|	LuaTokenKind_Eq
	|	'|'
	|	'~'
	|	'&'
	|	LuaTokenKind_Shl
	|	LuaTokenKind_Shr
	|	LuaTokenKind_Concat
	|	'+'
	|	'-'
	|	'*'
	|	'/'
	|	'%'
	|	LuaTokenKind_FloorDiv
	|	'^'
	;

un_op
	:	'~'
	|	'-'
	|	'#'
	|	LuaTokenKind_Not
	;
